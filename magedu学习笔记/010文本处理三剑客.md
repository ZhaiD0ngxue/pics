010文本处理三剑客

# 文本处理三剑客 


* grep,主要对文本行基于模式进行过滤
* sed,文本编辑工具  
* awk,文本报告生成器  

## grep  
作用和原理:文本搜索工具,根据用户指定的"模式"对目标文本进行逐行匹配,打印匹配成功的行.  
模式:由正则表达式字符及文本字符所编写的过滤条件.  
格式:  

```
grep [option] PATTERN [file...]
```

常见选项:  

```
-color=auto		对匹配到的文本着色显示
-m #			匹配#次后停止
-v				显示不被pattern匹配到的行,即取反。
-i				忽略字符大小写
-n				显示匹配的行号
-c				统计匹配的行数
-o				仅显示匹配到的字符串,不显示整行
-q				静默模式，不输出任何信息,常结合$?来使用.
-A #			after,后#行
-B #			before,前#行
-C #			context,前后各#行
-e				实现多个选项间的逻辑or关系,如grep- e'cat' -e 'dog' file
-w				匹配整个单词,单词的定义是只能由字母数字下划线组成,其他字符都会被识别为单词的边界
-E				使用ERE,相当于egrep
-F				不支持正则表达式,相当于fgrep
-f fi1e			根据模式文件处理
-r				递归目录,但不处理软链接
-R				递归目录,但处理软链接
```

特殊用法

```
[root@zdx data]# cat f1
a
b
c
d
[root@zdx data]# cat f2
1
2
a
b
[root@zdx data]# grep -f f1 f2	#可以用来取两个文件中的相同行  
a
b
[root@zdx data]#


[root@zdx data]# cat /etc/passwd | grep "root" | grep "bash" 	#和的关系,过滤既符合条件1也符合条件2的行或字符串. 
root:x:0:0:root:/root:/bin/bash
[root@zdx data]#

 

[root@zdx data]# cat pattern	#定义了一个文件,记录多个pattern
root
zhaidx
[root@zdx data]# grep -f pattern /etc/passwd	#匹配文件中的多个pattern
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin
zhaidx:x:1000:1000:zhaidx:/home/zhaidx:/bin/bash
[root@zdx data]#

 ```


## sed  

### 原理  
![](https://raw.githubusercontent.com/ZhaiD0ngxue/pics/main/img/10-1.png) 

Sed行编辑器,是从文件或管道中读取一行，处理一行，输出一行；再读取一行，再处理一行，再输出一行，直到最后一行。  
每当处理一行时，把当前处理的行存储在临时缓冲区中，称为模式空间（PatternSpace），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。  
一次处理一行的设计模式使得sed性能很高，sed在读取大文件时不会出现卡顿的现象。  

如果使用vi命令打开几十M上百M的文件，明显会出现有卡顿的现象，这是因为vi命令打开文件是一次性将文件加载到内存，然后再打开。Sed就避免了这种情况，一行一行的处理，打开速度非常快，执行速度也很快.  

### 基本用法  

格式:  

```
sed [option]... 'script;script;...' [inputfile...]
```  

**option:**  

```
-n 		#不输出模式空间内容到屏幕，即不自动打印
-e 		#多点编辑
-f FILE 	#从指定文件中读取编辑脚本
-r, -E 		#使用扩展正则表达式
-i.bak 		#备份文件并原处编辑,备份文化添加指定的.bak后缀,当然也可以指定其他后缀
-s 		#将多个文件视为独立文件，而不是单个连续的长文件流
```

**script:**  

```
'地址命令'
```

* 地址 


*地址界定这一部分也是可以使用正则的*
```
1. 不给地址：对全文进行处理
2. 单地址：
	#：指定的行，$：最后一行
	/pattern/：被此处模式所能够匹配到的每一行
3. 地址范围：
	#,#   从#行到第#行，例如3，6 从第3行到第6行
	#,+#   从#行到+#行，例如3,+4 表示从3行到第7行
	/pat1/,/pat2/
	#,/pat/
4. 步进：~
	1~2 奇数行
	2~2 偶数行
```  

* 命令  

```
p 		#打印当前模式空间内容，追加到默认输出之后
Ip		#忽略大小写输出
d 		#删除模式空间匹配的行，并立即启用下一轮循环
a [\]text 		#在指定行后面追加文本，支持使用\n实现多行追加
i [\]text 		#在行前面插入文本
c [\]text 		#替换行为单行或多行文本
w file 		#保存模式匹配的行至指定文件
r file 		#读取指定文件的文本至模式空间中匹配到的行后
= 		#为模式空间中的行打印行号
! 		#模式空间中匹配行取反处理
q 		#结束或退出sed

s/pattern/string/修饰符 		#查找替换,支持使用其它分隔符，可以是其它形式：s@@@，s###
替换修饰符：
	g 		#行内全局替换
	p 		#显示替换成功的行
	w /PATH/FILE 	#将替换成功的行保存至文件中
	I,i 	#忽略大小写
```  


范例:  

```
#多点编辑
[root@zdx ~]#sed -e '2d' -e '4d' seq.log
#先过滤出sd的分区,然后使用查找,里面又使用了后向引用,并将引用进行输出.
[root@zdx ~]# df | sed -En '/^\/dev\/sd/s@.* ([0-9]+)%.*@\1@p'	

[root@zdx ~]#sed '/^#/d;/^$/d' /etc/httpd/conf/httpd.conf
[root@zdx ~]#grep -Ev '^#|^$' /etc/httpd/conf/httpd.conf
[root@zdx ~]#sed -i.orig '2d;4d' seq.log
```  

这里要注意:  
***有空格的情况,/dev/sda3是没有被匹配到的,所以在替换的时候会被遗留下来***
```
[root@zdx ~]# df | sed -nr '/^\/dev\/sd/s# .* ([0-9]+)%.*# \1#p'
/dev/sda2 2
/dev/sda3 1
/dev/sda1 13
[root@zdx ~]# df | sed -nr '/^\/dev\/sd/s#.* ([0-9]+)%.*# \1#p'
 2
 1
 13
[root@zdx ~]# 
```

### sed的高级用法  
sed 中除了模式空间，还另外还支持保持空间（Hold Space）,利用此空间，可以将模式空间中的数据，临时保存至保持空间，从而后续接着处理，实现更为强大的功能。  

常见高级命令:

```
P 打印模式空间开端至\n内容，并追加到默认输出之前
h 把模式空间中的内容覆盖至保持空间中
H 把模式空间中的内容追加至保持空间中
g 从保持空间取出数据覆盖至模式空间
G 从保持空间取出内容追加至模式空间
x 把模式空间中的内容与保持空间中的内容进行互换
n 读取匹配到的行的下一行覆盖至模式空间
N 读取匹配到的行的下一行追加至模式空间
d 删除模式空间中的行
D 如果模式空间包含换行符，则删除直到第一个换行符的模式空间中的文本，并不会读取新的输入行，而使用合成的模式空间重新启动循环。如果模式空间不包含换行符，则会像发出d命令那样启动正常的新循环
```  

